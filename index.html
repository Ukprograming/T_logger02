<!-- FILE: index.html (T_logger build v11: sensor selection on UI) -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DS18B20 温度ロガー (Web Serial)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Chart.js のデフォルトを少し大きめ/太め＆点表示に
    Chart.defaults.font.size = 14;
    Chart.defaults.font.family = 'system-ui, sans-serif';
    Chart.defaults.elements.line.borderWidth = 3;
    Chart.defaults.elements.point.radius = 3;
    Chart.defaults.elements.point.hoverRadius = 5;
    Chart.defaults.elements.point.hitRadius = 6;
  </script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    .row { display:flex; flex-wrap: wrap; gap:8px; align-items: center; }
    label { margin-right: 8px; }
    #log { white-space: pre; max-height: 200px; overflow:auto; background:#f7f7f7; padding:8px; border:1px solid #ddd; }
    button { padding:6px 12px; }
    input, select { padding:4px 6px; }
  </style>
</head>
<body>
  <h1>DS18B20 温度ロガー (Web Serial)</h1>
  <div class="row">
    <button id="connectBtn">ポート接続</button>
    <button id="disconnectBtn" disabled>切断</button>

    <label>使用センサ：
      <select id="modeSel" title="温度計1=GPIO13 / 温度計2=GPIO27">
        <option value="1">温度計1のみ (GPIO13)</option>
        <option value="2" selected>温度計1+2 (GPIO13+GPIO27)</option>
      </select>
    </label>

    <label>分解能：
      <select id="resSel">
        <option value="12" selected>12-bit (～0.0625℃ / 750ms)</option>
        <option value="11">11-bit (～0.125℃ / 375ms)</option>
        <option value="10">10-bit (～0.25℃ / 188ms)</option>
        <option value="9">9-bit (～0.5℃ / 94ms)</option>
      </select>
    </label>
    <label>周期(ms)：<input type="number" id="periodIn" value="1000" min="50" step="50"></label>
    <label>表示ウィンドウ(分)：<input type="number" id="windowMin" value="10" min="1" step="1"></label>
  </div>

  <div class="row" style="margin-top:8px;">
    <button id="startBtn" disabled>記録開始</button>
    <button id="stopBtn" disabled>停止</button>
    <button id="markBtn" disabled>マーカー</button>
    <button id="clearBtn">表示クリア</button>
    <button id="downloadBtn" disabled>CSVダウンロード</button>
    <button id="scanBtn" disabled>再スキャン (SCAN/HEADER)</button>
  </div>

  <p id="status">未接続</p>
  <canvas id="chart" height="120"></canvas>
  <h3>受信ログ</h3>
  <div id="log"></div>

<script>
'use strict';
console.log('T_logger build v11');

////////////////////////////////////////////////////////////////////////////////
// グラフ
////////////////////////////////////////////////////////////////////////////////
const ctx = document.getElementById('chart').getContext('2d');
const chart = new Chart(ctx, {
  type: 'line',
  data: { labels: [], datasets: [] },
  options: {
    animation: false,
    parsing: false,
    normalized: true,
    spanGaps: true,
    interaction: { mode: 'nearest', intersect: false },
    plugins: {
      legend: { display: true, position: 'bottom', labels: { font: { size: 14 } } }
    },
    elements: { line: { borderWidth: 3 }, point: { radius: 3, hoverRadius: 5 } },
    scales: {
      x: { type: 'linear', display: false },
      y: { title: { display: true, text: 'Temperature (°C)', font: { size: 16 } },
           ticks: { font: { size: 14 } } }
    }
  }
});

function ensureDatasets(n) {
  while (chart.data.datasets.length < n) {
    chart.data.datasets.push({
      label: `T${chart.data.datasets.length}`,
      data: [],
      fill: false,
      borderWidth: 3,
      pointRadius: 3,
      pointHoverRadius: 5,
      hidden: false
    });
  }
}
function clearAllData() {
  chart.data.datasets.forEach(ds => ds.data = []);
  chart.update();
}

function trimWindow(windowMs) {
  const cutoff = performance.now() - windowMs;
  chart.data.datasets.forEach(ds => {
    while (ds.data.length && ds.data[0].x < cutoff) ds.data.shift();
  });
}

function pushSample(tsPerf, temps) {
  ensureDatasets(temps.length);
  temps.forEach((t, i) => {
    if (t == null || !Number.isFinite(t)) return;
    chart.data.datasets[i].data.push({ x: tsPerf, y: t });
  });
  chart.update('none');
}

////////////////////////////////////////////////////////////////////////////////
// Web Serial 状態
////////////////////////////////////////////////////////////////////////////////
let port, reader, writer, readLoopActive = false, connecting = false;
let lineBuf = '';
let sensorCount = 0;
let startPerfBase = performance.now();
let csvRows = [];
let running = false;

// 「温度計1 / 2」の想定ピン（スケッチと合わせる）
const TH1_PIN = 13;
const TH2_PIN = 27;

// ヘッダから得たメタ（index -> {pin?, bus?, rom?}）
const sensorMeta = []; // e.g., sensorMeta[0] = {pin:13, bus:1, rom:'28...'}
function resetMeta() { sensorMeta.length = 0; }

// 選択中の表示対象 index を返す
function getVisibleIndices() {
  const wantTwo = modeSel.value === '2';
  if (!sensorCount) return [];

  // メタがあれば pin で厳密に選別。なければ 0/1 の慣習で。
  const idxOfPin = (pin) => {
    for (let i = 0; i < sensorCount; i++) {
      if (sensorMeta[i]?.pin === pin) return i;
    }
    return null;
  };

  const i1 = idxOfPin(TH1_PIN);
  const i2 = idxOfPin(TH2_PIN);

  const idx1 = (i1 != null) ? i1 : 0;
  const idx2 = (i2 != null) ? i2 : (sensorCount > 1 ? 1 : null);

  if (wantTwo) {
    const out = [];
    if (idx1 != null) out.push(idx1);
    if (idx2 != null && idx2 !== idx1) out.push(idx2);
    return out;
  } else {
    return (idx1 != null) ? [idx1] : [0];
  }
}

// 可視状態を datasets に反映
function applyVisibility() {
  const vis = new Set(getVisibleIndices());
  chart.data.datasets.forEach((ds, i) => ds.hidden = !vis.has(i));
  chart.update();
}

// epoch 換算基準
const timeOriginMs = (typeof performance.timeOrigin === 'number')
  ? performance.timeOrigin : (Date.now() - performance.now());

////////////////////////////////////////////////////////////////////////////////
// UI 要素
////////////////////////////////////////////////////////////////////////////////
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const markBtn = document.getElementById('markBtn');
const clearBtn = document.getElementById('clearBtn');
const downloadBtn = document.getElementById('downloadBtn');
const scanBtn = document.getElementById('scanBtn');
const resSel = document.getElementById('resSel');
const periodIn = document.getElementById('periodIn');
const windowMin = document.getElementById('windowMin');
const modeSel = document.getElementById('modeSel');

function log(s) { logEl.textContent += s + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function setUIConnected(yes) {
  connectBtn.disabled = yes; disconnectBtn.disabled = !yes;
  startBtn.disabled = !yes; stopBtn.disabled = !yes;
  markBtn.disabled = !yes; downloadBtn.disabled = !yes;
  scanBtn.disabled = !yes;
}

////////////////////////////////////////////////////////////////////////////////
// 送受信
////////////////////////////////////////////////////////////////////////////////
const encoder = new TextEncoder();
async function sendLine(s) { if (!writer) return; console.log('TX>', s); await writer.write(encoder.encode(s + '\n')); }

async function disconnect() {
  readLoopActive = false;
  try { if (reader) await reader.cancel(); } catch {}
  try { if (writer) writer.releaseLock(); } catch {}
  try { if (reader) reader.releaseLock(); } catch {}
  try { if (port)   await port.close(); } catch {}
  reader = writer = undefined;
  setUIConnected(false);
  statusEl.textContent = '未接続';
  statusEl.style.color = '';
  log('# Disconnected');
}

async function connect() {
  if (connecting) return; connecting = true;
  try {
    if (!('serial' in navigator)) { alert('Web Serial未対応（Chrome/Edge、HTTPS必須）'); return; }
    if (port) await disconnect();

    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });

    const textDecoder = new TextDecoderStream();
    port.readable.pipeTo(textDecoder.writable);
    reader = textDecoder.readable.getReader();
    writer = port.writable.getWriter();

    setUIConnected(true);
    statusEl.textContent = '接続中';
    log('# Connected');

    // 初期化
    await sendLine(`RES ${resSel.value}`);
    await sendLine(`PERIOD ${periodIn.value}`);
    await sendLine('SCAN');
    await sendLine('HEADER');

    readLoopActive = true;
    readLoop();
  } catch (e) {
    console.error(e);
    alert('ポートを開けませんでした。IDEのシリアルモニタ/他タブを閉じ、USB抜き差し＆権限確認。\n\n詳細: ' + (e?.message || e));
    try { if (port && port.readable && !reader) await port.close(); } catch {}
    port = undefined;
    setUIConnected(false);
  } finally { connecting = false; }
}

////////////////////////////////////////////////////////////////////////////////
// 受信パース
////////////////////////////////////////////////////////////////////////////////
function parseHeaderLine(raw) {
  try {
    const line = String(raw).replace(/\uFEFF/g, '').trim();

    // # SENSORS : n
    if (/^#\s*SENSORS\b/i.test(line)) {
      const colon = line.indexOf(':');
      const after = colon >= 0 ? line.slice(colon + 1).trim() : '';
      const n = Number.parseInt(after, 10);
      sensorCount = Number.isFinite(n) ? n : 0;
      ensureDatasets(sensorCount);
      chart.update();

      // 一旦可視状態を更新（後でSENSOR行でpinが分かれば再更新）
      applyVisibility();

      // ステータス
      const wantTwo = (modeSel.value === '2');
      if (sensorCount === 0) {
        statusEl.textContent = 'センサ未検出（配線/ピン/抵抗を確認）';
        statusEl.style.color = 'crimson';
      } else if (wantTwo && sensorCount < 2) {
        statusEl.textContent = `検出センサ: ${sensorCount}（2台モード選択中だが片方未検出）`;
        statusEl.style.color = 'darkorange';
      } else {
        statusEl.textContent = `検出センサ: ${sensorCount}`;
        statusEl.style.color = '';
      }
      return;
    }

    // # SENSOR<idx> : ROM  BUS=x PIN=y
    if (/^#\s*SENSOR\b/i.test(line)) {
      const m = line.match(/^#\s*SENSOR(\d+)\s*:\s*([0-9A-Fa-f]{16})(?:.*?\bBUS=(\d+))?(?:.*?\bPIN=(\d+))?/);
      if (m) {
        const idx = parseInt(m[1], 10);
        const rom = m[2].toUpperCase();
        const bus = m[3] ? parseInt(m[3], 10) : undefined;
        const pin = m[4] ? parseInt(m[4], 10) : undefined;

        ensureDatasets(idx + 1);
        chart.data.datasets[idx].label = `T${idx} (${rom}${pin!=null?`,PIN=${pin}`:''})`;

        sensorMeta[idx] = { rom, bus, pin };
        applyVisibility(); // PINが分かった段階で再適用
        chart.update();
      }
      return;
    }
  } catch (e) {
    console.warn('parseHeaderLine failed:', raw, e);
  }
}

function parseDataLine(line) {
  const parts = line.split(',');
  if (parts.length < 2) return;

  const tsMs = Number.parseInt(parts[0].trim(), 10);
  if (!Number.isFinite(tsMs)) return;

  const temps = [];
  for (let i = 1; i < parts.length; i++) {
    const sv = parts[i].trim();
    const v = sv === '' ? NaN : Number.parseFloat(sv);
    temps.push(Number.isFinite(v) ? v : null);
  }

  const windowMs = Math.max(1, Number.parseInt(windowMin.value, 10)) * 60_000;
  const tsPerf = startPerfBase + tsMs;
  pushSample(tsPerf, temps);
  trimWindow(windowMs);

  // CSVは選択中のみ保存
  const visIdx = getVisibleIndices();
  const rowTemps = visIdx.map(i => temps[i] ?? '');
  const epochMs = (performance.timeOrigin || (Date.now() - performance.now())) + tsPerf;
  if (Number.isFinite(epochMs)) {
    try {
      const iso = new Date(epochMs).toISOString();
      csvRows.push([iso, ...rowTemps]);
    } catch {}
  }
}

async function readLoop() {
  resetMeta();
  while (readLoopActive) {
    const { value, done } = await reader.read();
    if (done) break;
    lineBuf += value;
    let idx;
    while ((idx = lineBuf.indexOf('\n')) >= 0) {
      const line = lineBuf.slice(0, idx).replace(/\r$/, '');
      lineBuf = lineBuf.slice(idx + 1);
      if (!line) continue;

      if (line.startsWith('#')) {
        try { parseHeaderLine(line); } catch {}
        log(line);
        continue;
      }
      parseDataLine(line);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// ハンドラ
////////////////////////////////////////////////////////////////////////////////
connectBtn.onclick = connect;
disconnectBtn.onclick = disconnect;
scanBtn.onclick = async () => { await sendLine('SCAN'); await sendLine('HEADER'); };

startBtn.onclick = async () => {
  await sendLine(`RES ${resSel.value}`);
  await sendLine(`PERIOD ${periodIn.value}`);
  await sendLine('START');
  running = true;
  statusEl.textContent = '記録中';
  statusEl.style.color = '';
  log('# START');
};
stopBtn.onclick = async () => {
  await sendLine('STOP');
  running = false;
  statusEl.textContent = '停止';
  statusEl.style.color = '';
  log('# STOP');
};
markBtn.onclick = () => { const ts = new Date().toISOString(); log(`# MARK ${ts}`); };
clearBtn.onclick = () => { clearAllData(); csvRows = []; log('# Cleared'); };
downloadBtn.onclick = () => {
  const visIdx = getVisibleIndices();

  const header = ['timestamp_iso'];
  visIdx.forEach(i => header.push(`${chart.data.datasets[i]?.label?.split(' ')[0] || `T${i}`}_C`));

  const lines = [header.join(',')];
  for (const row of csvRows) lines.push(row.join(','));
  const blob = new Blob(["\uFEFF" + lines.join('\n')], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `ds18b20_log_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
  a.click();
  URL.revokeObjectURL(url);
};

// 使用センサ切替：可視更新＋（必要なら）注意表示
modeSel.onchange = () => {
  applyVisibility();
  // 切り替え時にグラフは残す/消すはお好み。ここでは残す。
  // 消したい場合は clearAllData(); を有効に。
};

window.addEventListener('beforeunload', async () => { try { await disconnect(); } catch {} });
</script>
</body>
</html>
